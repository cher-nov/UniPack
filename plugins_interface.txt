/* =================================================================== */

// Константы результата сжатия и распаковки
#define UP_OK 0 // процесс прошёл успешно
#define UP_UNKNOWN_ERROR (-1) // внутренняя ошибка библиотеки
#define UP_INTERNAL_ERROR (-2) // неизвестная ошибка процесса
#define UP_DATA_ERROR (-3) // ошибка входных данных
#define UP_MEMORY_ERROR (-4) // ошибка памяти

/* =================================================================== */

/*
Возвращает строку-идентификатор.
Используются только первые 4 символа идентификатора - нет нужды передавать
строку большего размера, равно как и завершать её нуль-терминатором.
*/
char* up_info_name()

// Возвращает версию библиотеки-плагина.
int up_info_version()

/* =================================================================== */

// Инициализирует сжатие.
void up_pack_init(
  size_t pack_size  // полный размер данных, которые будут сжаты
)

/*
Сжимает переданный в функцию кусок данных, сжатое кладёт в буфер outbuf_ptr
до его заполнения. Важно: под "заполнением" подразумевается НЕ заполнение
всех outbuf_size байт буфера, а отсутствие места для записи следующего
кванта сжатых данных.
Возвращает точный размер сжатого куска в байтах или 0 в случае ошибки.
Если outbuf_size настолько мал, что не удалось записать в outbuf_ptr ни
одного кванта сжатых данных, то это считается ошибкой UP_MEMORY_ERROR.
*/
size_t up_pack_chunk(
  void* chunk_ptr,    // буфер с куском данных для сжатия
  size_t chunk_size,  // размер этих данных
  void* outbuf_ptr,   // буфер для сжатых данных (уже выделен)
  size_t outbuf_size  // размер этого буфера
)

/*
Освобождает все ресурсы, затраченные на сжатие.
Возвращает результат сжатия (см. константы выше)
*/
int up_pack_end()

/* =================================================================== */

// Инициализирует распаковку.
void up_unpack_init(
  size_t data_size  // полный размер данных, которые будут распакованы
)

/*
Распаковывает переданный в функцию кусок данных, распакованное кладёт в
буфер outbuf_ptr до его заполнения. Важно: под "заполнением" подразумевается
НЕ заполнение всех outbuf_size байт буфера, а отсутствие места для записи
следующего кванта распакованных данных.
Возвращает точный размер распакованного куска в байтах или 0 в случае ошибки.
Если outbuf_size настолько мал, что не удалось записать в outbuf_ptr ни
одного кванта распакованных данных, то это считается ошибкой UP_MEMORY_ERROR.
*/
size_t up_unpack_chunk(
  void* chunk_ptr,    // буфер с куском данных для распаковки
  size_t chunk_size,  // размер этих данных
  void* outbuf_ptr,   // буфер для распакованных данных (уже выделен)
  size_t outbuf_size  // размер этого буфера
)

/*
Освобождает все ресурсы, затраченные на распаковку.
Возвращает результат распаковки (см. константы выше)
*/
int up_unpack_end()



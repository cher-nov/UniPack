/* =================================================================== */

// Рекомендуемые состояния процессов сжатия и распаковки
#define UP_OK 0 // процесс прошёл успешно
#define UP_UNKNOWN_ERROR (-1) // неизвестная ошибка процесса
#define UP_INTERNAL_ERROR (-2) // внутренняя ошибка библиотеки
#define UP_DATA_ERROR (-3) // ошибка входных данных
#define UP_MEMORY_ERROR (-4) // ошибка памяти

/* =================================================================== */

/*
Возвращает строку-идентификатор. Будут использованы только первые
4 символа идентификатора - нет нужды передавать строку большего размера.
*/
char* up_info_name()

// Возвращает версию библиотеки-плагина.
int up_info_version()

/*
Возвращает NULL если ошибок не было, в противном случае возвращает
указатель на C-строку, описывающую ошибку, и сбрасывает состояние ошибки
внутри библиотеки.
*/
char* up_last_error()

/* =================================================================== */

// Инициализирует сжатие.
void up_pack_init(
  unsigned long long int pack_size
    // полный размер данных, которые будут сжаты
)

/*
Сжимает переданный в функцию кусок данных, сжатое кладёт в буфер outbuf_ptr
до его заполнения. Важно: под "заполнением" подразумевается НЕ заполнение
всех outbuf_size байт буфера, а отсутствие места для записи следующего
кванта сжатых данных.
Возвращает точный размер сжатого куска в байтах или 0 в случае ошибки.
Если outbuf_size настолько мал, что не удалось записать в outbuf_ptr ни
одного кванта сжатых данных, то это считается ошибкой UP_MEMORY_ERROR.
Стоит учесть, что функция записывает в outbuf_ptr незаполненные кванты
данных только в том случае, если этот кусок последний и есть место для их
записи.
*/
size_t up_pack_chunk(
  void* chunk_ptr,    // буфер с куском данных для сжатия
  size_t chunk_size,  // размер этих данных
  void* outbuf_ptr,   // буфер для сжатых данных (уже выделен)
  size_t outbuf_size  // размер этого буфера
)

// Освобождает все ресурсы, затраченные на сжатие.
void up_pack_end()

/* =================================================================== */

// Инициализирует распаковку.
void up_unpack_init(
  unsigned long long int data_size
    // полный размер данных, которые будут распакованы
)

/*
Распаковывает переданный в функцию кусок данных, распакованное кладёт в
буфер outbuf_ptr до его заполнения. Важно: под "заполнением" подразумевается
НЕ заполнение всех outbuf_size байт буфера, а отсутствие места для записи
следующего кванта распакованных данных.
Возвращает точный размер распакованного куска в байтах или 0 в случае ошибки.
Если outbuf_size настолько мал, что не удалось записать в outbuf_ptr ни
одного кванта распакованных данных, то это считается ошибкой UP_MEMORY_ERROR.
*/
size_t up_unpack_chunk(
  void* chunk_ptr,    // буфер с куском данных для распаковки
  size_t chunk_size,  // размер этих данных
  void* outbuf_ptr,   // буфер для распакованных данных (уже выделен)
  size_t outbuf_size  // размер этого буфера
)

// Освобождает все ресурсы, затраченные на распаковку.
void up_unpack_end()


